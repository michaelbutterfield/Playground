(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "cucumber", "underscore", "./binding-registry", "./managed-scenario-context", "./step-binding"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const cucumber_1 = require("cucumber");
    const _ = require("underscore");
    const binding_registry_1 = require("./binding-registry");
    const managed_scenario_context_1 = require("./managed-scenario-context");
    const step_binding_1 = require("./step-binding");
    //
    /**
     * The property name of the current scenario context that will be attached to the Cucumber
     * world object.
     */
    const SCENARIO_CONTEXT_SLOTNAME = "__SCENARIO_CONTEXT";
    /**
     * A set of step patterns that have been registered with Cucumber.
     *
     * In order to support scoped (or tagged) step definitions, we must ensure that any step binding is
     * only registered with Cucumber once. The binding function for that step pattern then becomes
     * responsible for looking up and execuing the step binding based on the context that is in scope at
     * the point of invocation.
     */
    const stepPatternRegistrations = new Map();
    // tslint:disable:no-bitwise
    /**
     * A class decorator that marks the associated class as a CucumberJS binding.
     *
     * @param requiredContextTypes An optional array of Types that will be created and passed into the created
     * object for each scenario.
     *
     * An instance of the decorated class will be created for each scenario.
     */
    function binding(requiredContextTypes) {
        return (target) => {
            ensureSystemBindings();
            const bindingRegistry = binding_registry_1.BindingRegistry.instance;
            bindingRegistry.registerContextTypesForTarget(target.prototype, requiredContextTypes);
            bindingRegistry
                .getStepBindingsForTarget(target.prototype)
                .forEach(stepBinding => {
                if (stepBinding.bindingType & step_binding_1.StepBindingFlags.StepDefinitions) {
                    let stepBindingFlags = stepPatternRegistrations.get(stepBinding.stepPattern.toString());
                    if (stepBindingFlags === undefined) {
                        stepBindingFlags = step_binding_1.StepBindingFlags.none;
                    }
                    if (stepBindingFlags & stepBinding.bindingType) {
                        return;
                    }
                    bindStepDefinition(stepBinding);
                    stepPatternRegistrations.set(stepBinding.stepPattern.toString(), stepBindingFlags | stepBinding.bindingType);
                }
                else if (stepBinding.bindingType & step_binding_1.StepBindingFlags.Hooks) {
                    bindHook(stepBinding);
                }
            });
            return target;
        };
    }
    exports.binding = binding;
    /**
     * Ensures that the 'cucumber-tsflow' hooks are bound to Cucumber.
     *
     * @param cucumber The cucumber object.
     *
     * The hooks will only be registered with Cucumber once regardless of which binding invokes the
     * function.
     */
    const ensureSystemBindings = _.once(() => {
        cucumber_1.Before(function (scenario) {
            this[SCENARIO_CONTEXT_SLOTNAME] = new managed_scenario_context_1.ManagedScenarioContext(scenario.name, _.map(scenario.tags, (tag) => tag.name));
        });
        cucumber_1.After(function () {
            const scenarioContext = this[SCENARIO_CONTEXT_SLOTNAME];
            if (scenarioContext) {
                scenarioContext.dispose();
            }
        });
        // Decorate the Cucumber step definition snippet builder so that it uses our syntax
        // let currentSnippetBuilder = cucumberSys.SupportCode.StepDefinitionSnippetBuilder;
        // cucumberSys.SupportCode.StepDefinitionSnippetBuilder = function (step, syntax) {
        //     return currentSnippetBuilder(step, {
        //         build: function (functionName: string, pattern, parameters, comment) {
        //             let callbackName = parameters[parameters.length - 1];
        //             return `@${functionName.toLowerCase()}(${pattern})\n` +
        //                    `public ${functionName}XXX (${parameters.join(", ")}): void {\n` +
        //                    `  // ${comment}\n` +
        //                    `  ${callbackName}.pending();\n` +
        //                    `}\n`;
        //         }
        //     });
        // }
    });
    /**
     * Binds a step definition to Cucumber.
     *
     * @param cucumber The cucumber object.
     * @param stepBinding The [[StepBinding]] that represents a 'given', 'when', or 'then' step definition.
     */
    function bindStepDefinition(stepBinding) {
        const bindingFunc = function () {
            const bindingRegistry = binding_registry_1.BindingRegistry.instance;
            const scenarioContext = this[SCENARIO_CONTEXT_SLOTNAME];
            const matchingStepBindings = bindingRegistry.getStepBindings(stepBinding.stepPattern.toString(), scenarioContext.scenarioInfo.tags);
            if (matchingStepBindings.length > 1) {
                let message = `Ambiguous step definitions for '${matchingStepBindings[0].stepPattern}':\n`;
                matchingStepBindings.forEach(matchingStepBinding => {
                    message =
                        message +
                            `\t\t${String(matchingStepBinding.targetPropertyKey)} (${matchingStepBinding.callsite.toString()})\n`;
                });
                return new Error(message);
            }
            const contextTypes = bindingRegistry.getContextTypesForTarget(matchingStepBindings[0].targetPrototype);
            const bindingObject = scenarioContext.getOrActivateBindingClass(matchingStepBindings[0].targetPrototype, contextTypes);
            bindingObject._worldObj = this;
            return bindingObject[matchingStepBindings[0].targetPropertyKey].apply(bindingObject, arguments);
        };
        Object.defineProperty(bindingFunc, "length", {
            value: stepBinding.argsLength
        });
        if (stepBinding.bindingType & step_binding_1.StepBindingFlags.given) {
            if (stepBinding.timeout) {
                cucumber_1.Given(stepBinding.stepPattern, { timeout: stepBinding.timeout }, bindingFunc);
            }
            else {
                cucumber_1.Given(stepBinding.stepPattern, bindingFunc);
            }
        }
        else if (stepBinding.bindingType & step_binding_1.StepBindingFlags.when) {
            if (stepBinding.timeout) {
                cucumber_1.When(stepBinding.stepPattern, { timeout: stepBinding.timeout }, bindingFunc);
            }
            else {
                cucumber_1.When(stepBinding.stepPattern, bindingFunc);
            }
        }
        else if (stepBinding.bindingType & step_binding_1.StepBindingFlags.then) {
            if (stepBinding.timeout) {
                cucumber_1.Then(stepBinding.stepPattern, { timeout: stepBinding.timeout }, bindingFunc);
            }
            else {
                cucumber_1.Then(stepBinding.stepPattern, bindingFunc);
            }
        }
    }
    /**
     * Binds a hook to Cucumber.
     *
     * @param cucumber The cucumber object.
     * @param stepBinding The [[StepBinding]] that represents a 'before', or 'after', step definition.
     */
    function bindHook(stepBinding) {
        const bindingFunc = function () {
            const scenarioContext = this[SCENARIO_CONTEXT_SLOTNAME];
            const contextTypes = binding_registry_1.BindingRegistry.instance.getContextTypesForTarget(stepBinding.targetPrototype);
            const bindingObject = scenarioContext.getOrActivateBindingClass(stepBinding.targetPrototype, contextTypes);
            bindingObject._worldObj = this;
            return bindingObject[stepBinding.targetPropertyKey].apply(bindingObject, arguments);
        };
        Object.defineProperty(bindingFunc, "length", {
            value: stepBinding.argsLength
        });
        if (stepBinding.bindingType & step_binding_1.StepBindingFlags.before) {
            if (stepBinding.tag === binding_registry_1.DEFAULT_TAG) {
                cucumber_1.Before(bindingFunc);
            }
            else {
                cucumber_1.Before(String(stepBinding.tag), bindingFunc);
            }
        }
        else if (stepBinding.bindingType & step_binding_1.StepBindingFlags.after) {
            if (stepBinding.tag === binding_registry_1.DEFAULT_TAG) {
                cucumber_1.After(bindingFunc);
            }
            else {
                cucumber_1.After(String(stepBinding.tag), bindingFunc);
            }
        }
    }
});
//# sourceMappingURL=binding-decorator.js.map